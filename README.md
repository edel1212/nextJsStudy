# NextJs

```properties
# ℹ️ NextJs의 특징
#  - `Framework`이다.
#  - 정해진 틀(`Frame`)이 정해져 있고 그 틀에 맞춰서 개발을 진행하면 쉽게 구현이 가능하다.
#  - 기본적으로 필요한 Library가 설치 되어 있으며 필요한 경우 추가하는 식으로 진행하면 된다.
```

## `Library`와`Framework`의 차이

- Library
  - 내가 사용 하여 개발만 하는 개념이다 대체로 **내가 원하는 방향으로 사용해서 개발**하면 되는 개념이다.
    - 기본적인 `React.js`로 생각 하며 비교하면 쉽다
      - 틀이 없기에 자유로움 내가 직접 기준을 만들어 개발하면 된다.
        - 디렉토리 구조나 파일명 등 틀이 정해져 있지 않다.
- Framework
  - 틀이 정해져있어 그 **틀에 맞춰 개발**하면 된다.
  - NextJs를 생각하여 비교하면 된다.
  - 틀이 정해져 있기에 정해진 방식의 라우팅 방식 `Page or App Route`방식에 맞춰 디렉토리 구조 및 파일명이 있다.
    - 정해진 해당 프레임워크에 선점되어 있는 변수명등이 정해져 있다.
  - `IoC(Inversion of Control) - 제어의 역전`을 생각하면 된다.
    - 메소드나 객체의 호출작업을 개발자가 결정하는 것이 아니라 외부에서 결정한다.

## 설치 방법 및 서버 실행

- `npx create-next-app@latest` 명령어를 사용해서 nextJs 프로젝트를 생성해준다.
  - 옵션
    - Would you like to use TypeScript?
      - 타입스크립트 사용 여부
    - Would you like to use ESLint?
      - EsLint 사용 여부
    - Would you like to use Tailwind CSS?
      - Tailwind CSS 사용 여부
    - Would you like to use `src/` directory?
      - 사용 하면 src 디렉토리 생성된다.
    - Would you like to use App Router? (recommended)
      - ⭐ 라우팅 방식 설정
        - 이전에는 `pages` 디렉토리 방법을 사용해서 라우팅을 했다
        - 최근에는 `App` 라우팅 방식이 생성되었다.
          - `React`에서 추천하는 방법이다. [13버전부터 추가 되었음]
    - Would you like to customize the default import alias (@/\*)?
      - Import 시 별칭을 만들어서 불러올지 여부
  - 서버 실행
    - `npm run dev`

<br/>
<hr/>

## Routing - Pages 사용 방법 [Next13 이전]

- Next.js에서는 따로 `react-router-dom`를 설치해 줄 필요가 없다.
  - 이미 설치 및 설정이 전부 되어있음.
- `pages`폴더 내부의 js파일명 기준으로 `/path`가 결정된다.
  - ⭐️ `index.js`의 경우 특별한 케이스로 무조건 root Path로 인식한다.
- `.js`파일의 파일명이 중요하지 내부의 함수명은 자유이다. Url의 Path에 영향이 없다.
  ```javascript
  // about.js
  /**
   * 중요 포인트
   * - 함수명은 어떤것이든 상관 없다 routing의 기준은 해당 js파일명을 따라 생성된다.
   * - export할 경우 무조건 "epxort default" 이어야한다!
   *  - error : Error: The default export is not a React Component in page
   */
  export default function google() {
    return <div>about</div>;
  }
  ```
- `export`는 필수이며 무조건 `export default`를 사용해서 모듈화 해줘야한다.
  - Next.js 프레임워크 자체에서 그렇게 정의하였으므로 따라 사용하면 된다.

<br/>
<hr/>

## Routing - App Router 사용 방법 [Next13 이후]

- `Next13`이전은 파일명이 각각의 세그먼트였다면 이후는 폴더명이 세그먼트명이다
- 해당 폴더명 -> `page.js` 를 사용해줘야한다. ⭐️ 파일명은 고정임

  - 파일 경로
    - `src/app/여기가 세그먼트명/page.js`
  - 예시 코드

    - page.js

      ```javascript
      /**
       * 👉 동장 순서
       * - http://localhost:3000/create 호출
       * - src ->  app -> 해당 요청에 맞는 폴더명을 찾음
       * - 해당 폴더를 찾으면 `page.js`파일이 있다면 해당 컴포넌트를 랜더링 해줌
       *  -> 해당 js명이 `page.js`가 아니라면 404 페이지를 반환함
       */
      export default function page() {
        return <div>src - app - paht명 - page.js </div>;
      }
      ```

### 서버에서 데이터를 받아 와 사용하기

- App Router은 기본적으로 `Server Component`방식이다 따라서 일반적인 React 방식으로 사용하려하면 에러가 발생한다.
- 💬 간단하게 이해
  - Client Component
    - `useState`
    - `useEffect`
    - `onClick`
    - `onChange`
    - `useRouter`
    - `useParams`
  - Server Component
    - `secire data`
    - `cookie`
    - `header`
- 👉 서버간 통신 예제

  - `Client Component` 방식

    - 기본적으로 `app router`의 경우 Server Component방식 이기에 상단에 따로 **"use client";** 선언이 필요하다

    ```javascript
    // ⭐️ 꼭 선언해 줘야한다
    "use client";

    import Link from "next/link";
    import "./globals.css";
    import { useEffect, useState } from "react";

    // 👉 해당 코드는 "use client"를 사용 할 경우 사용이 불가능
    // export const metadata = {
    //   title: "Create Next App222",
    //   description: "Generated by create next app",
    // };

    export default function RootLayout({ children }) {
      const [topics, setTopics] = useState([]);
      useEffect(() => {
        fetch("http://localhost:9999/topics")
          .then((res) => res.json())
          .then((result) => setTopics(result))
          .catch((e) => console.log(e));
      }, []);

      console.log(topics);

      return <></>;
    }
    ```

  - `Server Component` 방식

        - `async` 와 `await`를 사용해야한다.

        ```javascript
        import Link from "next/link";
        import "./globals.css";

        export const metadata = {
          title: "Create Next App222",
          description: "Generated by create next app",
        };

        // ⭐️ async 선언은 필수 이다. fetch에서 await를 사용하기 위함
        export default async function RootLayout({ children }) {
          // 👉 await를 사용해서 fetch 사용
          const res = await fetch("http://localhost:9999/topics");
          const topics = await res.json();

          return (
            <html>
              <body>
                <ol>
                  {topics.map((item) => (
                    <li key={item.id}>
                      <Link href={`/read/${item.id}`}>{item.title}</Link>
                    </li>
                  ))}
                </ol>
              </body>
            </html>
          );
        }
        ```

### cache ?

- 기본적으로 Server Component 방식을 사용할 경우 새로고침을 해도 값을 최신값을 가져오지 않는다.
  - cache로 해당 값을 갖고 있으면 요청을 하지않기 떄문임.
- 다양한 cache 설정 방법이 있다 예제에서는 간단하게 해결 가능한 `no-cache`를 사용
- 사용 방법

  - layout.js [메인 화면 Component]

    ```javascript
    export default async function RootLayout({ children }) {
      const res = await fetch(
        "http://localhost:9999/topics",
        // 👉 cache: "no-cache"를 주어서 cache저장 대상에서 제외 시켜준다.
        {
          cache: "no-cache",
        }
      );
      const topics = await res.json();

      return <html></html>;
    }
    ```

  - page.js [글 작성 Event가 있는 Component]

    ```javascript
    "use client";
    import { useRouter } from "next/navigation";

    export default function page() {
      const router = useRouter();

      const submit = (e) => {
        fetch("http://localhost:9999/topics", options)
          .then((res) => res.json())
          .then((result) => {
            // 👉 router을 사용해서 통신에 성공할 경우 새로고침 한다.
            router.refresh();
            router.push(`/read/${result.id}`);
          });
      };

      return <div></div>;
    }
    ```

### 분리하기 - [💬 useParams() 사용 ]

- 기본적으로 `app rotuer`방식을 사용하면 `Server Component`방식이다 그럴 경우 만약 일정 부분에서 PathVariable이 필요하다면 ??
  - 해당 컴포넌트를 `"use client"`를 사용해서 `Client Component`로 변경한다.
  - 해당 부분을 새로운 컴포넌트로 나눠서 사용하는 방법 이있다.
- 하지만 예제의 경우 메인 `layout.js`에서 하단의 수정, 삭제 버튼을 id값의 유무로 보이고 안보이고 하고싶었다.
  - 전체적으로 `Client Component`로 만드는건 무리 .. 그렇기에 컴포넌트를 나눠준 후 `useParams()`사용으로 Id값 가져오기
- 사용 예시

  - layout.js [나누기 이전 👎]

    ```javascript
    import Link from "next/link";
    import "./globals.css";
    // ❌ 하지만 Client Component로 변경하기엔 어려운 상황임
    export const metadata = {
      title: "Create Next App222",
      description: "Generated by create next app",
    };
    export default async function RootLayout({ children }) {
      return (
        <html>
          <body>
            {children}
            /** * 👉 해당 부분이 http://localhost:3000/read/14 와 같이 * id에 따라
            보이고 안보이고 하고싶은 사오항 */
            <ul>
              <li>
                <Link href="/create">Create</Link>
              </li>
              <li>
                <Link href="/update/1">Update</Link>
              </li>
              <li>
                <button>Delete</button>
              </li>
            </ul>
          </body>
        </html>
      );
    }
    ```

  - Control.js [컴포넌트 나눔 👍]

    ```javascript
    // ⭐️ Client Component로 변경
    "use client";
    import Link from "next/link";
    import { useParams } from "next/navigation";

    export function Control() {
      // 👉 PathVariable값을 받아올 수 있게 되었다.
      const params = useParams();
      const id = params.id;
      console.log(id);
      return (
        <ul>
          <li>
            <Link href="/create">Create</Link>
          </li>
          // 👉 조건식을 사용해서 보이고 안보이고 설정
          {id ? (
            <>
              <li>
                <Link href="/update/1">Update</Link>
              </li>
              <li>
                <button>Delete</button>
              </li>
            </>
          ) : null}
        </ul>
      );
    }
    ```

  - layout.js
    ```javascript
    import Link from "next/link";
    import "./globals.css";
    import { Control } from "./Control";
    export const metadata = {
      title: "Create Next App222",
      description: "Generated by create next app",
    };
    export default async function RootLayout({ children }) {
      return (
        <html>
          <body>
            {children}
            <Control />
          </body>
        </html>
      );
    ```

<br/>
<hr/>

### `Link Tag`

- React에서는 `A Tag`를 사용하지 말자, 아니 사용하면 안된다.
  - 화면이 깜빡거림
  - 느림
  - 장점이 하나도 없으며 eslint에서도 사용하지 말라고 경고가 나옴
- `Link Tag` 장점
  - 화면이 깜빡이지 않고 페이지간 이동이 가능하며 속도 또한 훨씬 빨라 SPA느낌을 준다.
  - 따로 해당 Library를 설치할 필요 없이 NextJs에 포함되어 있어서 그냥 바로 `import` 하여 사용하면 된다.
  - `className`, `style`등등 여러가지를 사용이 가능하다.
- 예시 코드

  ```javascript
  // 👉 그냥 import 하고 사용하면 끝!
  import Link from "next/link";

  export default function NavBar() {
    /**
     *  👉 React를 사용하면 a Tag를 사용해서 페이지 이동을 사용하지 말자!!
     *     - 무조건 Link를 사용해주자! 그래야 싱글 페이지를 경험 하는 느낌을 낼 수 있음!! 기억하자!
     */
    return (
      <nav>
        <Link href="/" style={{ color: "red" }} className="hello">
          Home
        </Link>
        <Link href="/about">About</Link>
      </nav>
    );
  }
  ```

<br/>

### `useRouter()`

- 해당 Url에 대한 정보를 가져와서 사용이 가능하다.
- NextJs 설치 시 자동으로 설치되어 있기에 바로 사용하면 된다.
- 예시 코드

  ```javascript
  import Link from "next/link";
  import { useRouter } from "next/router";

  const activeNav = (path) => {
    // 💬 NextJs에서 기본적으로 router가 설치되어 있기 때문에 사용만 하면된다.
    //    - 해당 함수 내에는 rotuer에 대한 여러가지 정보를 받아서 사용이 가능함
    const router = useRouter;
    return {
      color: path === router().pathname ? "red" : null,
    };
  };

  export default function NavBar() {
    return (
      <nav>
        <Link href="/" style={activeNav("/")}>
          Home
        </Link>
        <Link href="/about" style={activeNav("/about")}>
          About
        </Link>
      </nav>
    );
  }
  ```

<br/>
<hr/>

## Style 적용 방법

- 방법 1 . `Css Module`을 사용하는 방법

  - 파일의 명명규칙이 정해져 있다.

    - `??.module.css` 형태이다 앞에는 자유지만 뒤에는 꼭 명명규칙에 맞춰주자
    - 사용 방법은 간단하다 `className`을 직접 지정해주는것이 아닌 `clasName={import 모듈명.클래스명}`로 적용하면 된다.
      - 여기서 장점은 해당 class명이 알아서 부여되어 중복의 걱정할 필요가 없다.

  - 사용 예시

    - NavBar.module.css

      ```css
      /*
      
      💬 해당 MoudleCss의 최고의 장점은 사용하는 className의 중복을 걱정하지 않아도 된다는 것이다.
          - 랜더링하여 화면에 사용될 경우 알아서 겹치지 않도록 자동으로 클래스명을 만들어서 사용됨!
          - 단 사용 방법은 "clasName={모듈명.클래스명}"으로 사용해줘야 한다는 것이다.
      */
      .nav {
        background-color: green;
        display: flex;
        justify-items: center;
      }

      .active {
        color: red;
      }

      .link {
        text-decoration: none;
      }
      ```

    - NavBar.js

      ```javascript
      import Link from "next/link";
      // 👉 사용 하려는 css modul import
      import styles from "./NavBar.module.css";

      export default function NavBar() {
        return (
          <nav>
            {/** 👉 다수의 className을 사용해주기 위해서는 배열 형태로 만들어 준 후 join(" ")을 사용해 주자 */}
            <Link href="??" className={[styles.active, styles.link].join(" ")}>
              cssMoulde 테스트
            </Link>
          </nav>
        );
      }
      ```

- 방법 2 . `style jsx` 적용 방법

  - 따로 Css파일을 만들 필요가 없다
  - 클래스명을 따로 지어줄 필요없이 태그명으로 바로 사용이 가능하다.
  - 하지만 뭔가 불편하다 코드가 길어지고 직관적인 느낌이 없음
  - 백틱 ``을 사용하여 작성해줘야한다.
  - 작성된 스타일은 모두 독립적으로 적용된다! 다른 컴포넌트에 영향이 없음 해당 컴포넌트의 태그만 영향이 있다
  - 사용 방법

    - NavBar.js

      ```javascript
      import Link from "next/link";
      import { useRouter } from "next/router";

      const activeNav = (path) => {
        return useRouter().pathname === path ? "active" : null;
      };

      export default function NavBar() {
        return (
          <nav>
            {/** 
               ⭐️ nexjs버전이 오르면서 Link 태그 내부 a태그 사용이 불가능한데 legacyBehavior를 사용하면 된다. 
                 - "style jsx"에서는 Link태그에 접근이 불가능하여 css적용이 어려움 ... 불편하다..
            */}
            <Link href="/" legacyBehavior>
              <a className={activeNav("/")}>Home</a>
            </Link>
            <Link href="/about" legacyBehavior>
              <a className={activeNav("/about")}>About</a>
            </Link>

            {/** 👉 아래와 같이 return 구문안에 작성 중요 포인트는 "jsx"를 사용해주고 ``을 사용해줘야한다는 것 */}
            <style jsx>{`
              nav {
                background-color: tomato;
              }
              a {
                text-decoration: none;
              }
              .active {
                color: yellow;
              }
            `}</style>
          </nav>
        );
      }
      ```

<br/>
<hr/>

## 공통영역 처리 방법 - 전역 처리

- spring의 jsp 따지면 `include` Tymeleaf로 따지면 `fagment`로 생각하면 좋다.
- 공통적인 틀을 만드는 것은 물론이고 Global css 또한 해당 위치에 적용해야한다 그렇지 않으면 에러가 발생한다.
  - ⭐️ 일반 컴포넌트에 CSS 적용 시 발생 하는 에러
    - Message : Global CSS cannot be imported from files other than your Custom <App>.
- 주의 사항

  - 1 . ⭐️ 파일명은 **무조건** `_app.js`이어야한다 . 프레임워크에서 컴포넌트중에서 가장 먼저 읽는 네이밍이기 때문이다!
  - 2 . 해당 컴포는트의 기본틀을 꼭 지켜주자

    - `{ Component, pagePrpos }` 파라미터로 받는 것
    - `<Component {...pagePrpos}></Component>`형태로 컴포넌트를 불러오는 것

    ```javascript
    /***
     * 👉 { Component, pagePrpos } 해당 파라미터 2개는 필수이다.
     * - 기본적인 틀이며 따르면 된다,.
     *  - Component 경우 우리가 생성하는 각각의 컴포넌트라 생각하고
     *  - pagePrpos 각각의 컴포넌트에 전달하는 pageProps이다
     */
    export default function App({ Component, pagePrpos }) {
      return (
        <>
          {/* ✅ 아래의 형식을 꼭 사용해야한다 스프레드 시트를 사용해서 pageProps를 넘겨주자 */}
          <Component {...pagePrpos}></Component>
        </>
      );
    }
    ```

- 활용 ( 전역 Css와 Nav Component 사용 )

  - \_app.js

    ```javascript
    // 👉 NavBar Import
    import NavBar from "@/component/NavBar";
    // 👉 전역 css를 불러와도 에러가 없다 👍
    import "../styles/globals.css";

    export default function App({ Component, pagePrpos }) {
      return (
        <>
          {/** 👉 Nav 컴포넌트 Call */}
          <NavBar></NavBar>

          <Component {...pagePrpos}></Component>

          <span>이런식으로 여러가지를 추가 가능함 ! Footer넣자!</span>
        </>
      );
    }
    ```

- `_app.js`를 사용할 경우 사용하는 패턴

  - 패턴 사용 이유
    - `_app.js`에는 공통적으로 사용해야하는 것들이 많이 Import 된다.
    - 그렇다면 엄청나게 길어질 것이며 이러한 코드는 보기도 관리하기도 힘들어진다.
  - 예시 코드

    - components -> Layout.js

      ```javascript
      import NavBar from "./NavBar";

      // 👉 하위로 들어온 모든 요소들은 children으로 받음
      export default function Layout({ children }) {
        return (
          <>
            <NavBar></NavBar>
            // 👉 사용
            <div>{children}</div>
          </>
        );
      }
      ```

    - \_app.js

      ```javascript
      import Layout from "@/component/Layout";
      import "../styles/globals.css";

      export default function App({ Component, pagePrpos }) {
        return (
          <>
            {/* ✅ Layout 하위에 들어온 컴포넌트 구조가 중요함 */}
            <Layout>
              <Component {...pagePrpos}></Component>
            </Layout>
          </>
        );
      }
      ```

<br/>
<hr/>

## Header 정보 변경

- NextJs에서는 Header 정보를 쉽게 바꿀 수 있는 Library가 기본적으로 설치되어 있어 편하게 사용이 가능하다.
- 해당 `Head` 또한 랜더링 될 때 적용되므로 공통적으로 랜더링 되는 위치에 적용하는것이 옳다.
  - 그렇지 않으면 만약 about 컴포넌트에만 작업했다면 about에서만 적용됨.
- 예시 코드

  - HeadTitle.js

    ```javascript
    // 👉 NextJs 설치 시 자동으로 설치되어 있는 라이브러리 Import!
    import Head from "next/head";

    // 👉 Object형태로 파라미터가 넘어오기 떄문에 {}사용 필수!
    export default function HeadTitle({ titleName }) {
      return (
        // 👉 Head 사용해서 header에서 사용하는 값 변경이 가능하다!
        <Head>
          <title>{titleName} | Moive!</title>
        </Head>
      );
    }
    ```

  - Layout.js

        ```javascript
        import HeadTitle from "./HeadTitle";
        import NavBar from "./NavBar";

        export default function Layout({ children }) {
          return (
            <>
              {/* 👉 titleName파라미터명을 맞춰서 넘겨주자 */}
              <HeadTitle titleName={"Movie!"}></HeadTitle>
              <NavBar></NavBar>
              <div>{children}</div>
            </>
          );
        }
        ```

<br/>
<hr/>

## 정적 파일 불러오는 방법

- NextJs에서 정적 파일은 public폴더 안에 존재한다.
- 불러오는 방법은 간단하게 "/파일"로 다른 경로작업 필요없이 불러올 수 있다. - 틀이 그렇게 잡혀있기 때문
- 예시 코드

  - index.js

  ```javascript
  export default function NavBar() {
    return (
      <nav>
        {/** 바로 public 내부의 vercel.svg를 불러옴 */}
        <img src="/vercel.svg"></img>
      </nav>
    );
  }
  ```

<br/>
<hr/>

## Image 태그 사용하는 방법

- NextJs에서는 Image 태그를 사용할 수 있다
- 사용 시 장점

  - Lazy loading 가능
  - 사이즈 최적화
  - Layout shift 방지
    - 이미지가 로딩전에 너비, 높이가 없어 레이아웃이 깨지는 것

- 사용 방법

  - `img/index.js` - 일반 `<img>, <Image>` 사용

    ```javascript
    import Image from "next/image";
    import React, { useEffect, useState } from "react";
    // ⭐️ Image 태그에 넣을 이미지 Import
    import picka from "/public/picka.png";

    export default function page() {
      return (
        <div>
          {/* 👉 일반 img 태그 */}
          <img src="/picka.png" width={"50%"} alt="이건 그냥 img" />

          <hr />

          {/* 👉 Image 태그 */}
          <Image
            // ✅ src 경로는 import 된 경로만 사용이 가능함!!!
            src={picka}
            alt="이건 최적화 적용"
            className="다 가능해"
            style={{ width: "50%", height: "100%" }}
          />
        </div>
      );
    }
    ```

  - `img/index.js` - 비동기 ` <Image>` 사용

    - ⭐️ 중요 포인트는 서버로 요청하는 도메인을 `next.config.js`에 꼭 등록해줘야 한다는 것이다.

    ```javascript
    import Image from "next/image";
    import React, { useEffect, useState } from "react";
    import picka from "/public/picka.png";

    export default function page() {
      const [imageData, setImageData] = useState(null);

      useEffect(() => {
        (async () => {
          try {
            const response = await fetch("/api/movies");
            const data = await response.json();
            setImageData(data.results[0].poster_path); // 데이터 설정
          } catch (error) {
            console.error("Error fetching image data:", error);
          }
        })();
      }, []);

      return (
        <div>
          {/* 👉 비동기 통신 */}
          <Image
            src={`https://image.tmdb.org/t/p/w500/${imageData}`}
            alt="비동기 통신으로 받음 next.config.js 설정 필요"
            width={400} // ⭐️ 필수 값
            height={300} // ⭐️ 필수 값
          />
        </div>
      );
    }
    ```

  - `next.config.js`

    ```javascript
    // ✅ .evn파일에 작성한 API Key를 불러옴
    const API_KEY = process.env.API_KEY;

    /** @type {import('next').NextConfig} */
    const nextConfig = {
      reactStrictMode: true,
      /**
       * 👉 해당 "source"에 잡힌 경로를 "destination"로 이동 시켜줌
       * - :path* 를 사용하면 뒤에 붙은 모든 path 정보를 그대로 넘겨줌
       * */
      async redirects() {
        return [
          {
            source: "/old-blog/:path*",
            destination: "/new-sexy-blog/:path*",
            // 💬 일반적으로 페이지 이동이 영구적으로 변경된 경우 permanent: true를 사용하고, 일시적인 변경의 경우 permanent: false를 사용합니다.
            permanent: false,
          },
        ];
      },
      /**
       * 👉 redirects()와는 다르게 "source"로 접근한 값을 "destination"로 변경해서 요청 함
       */
      async rewrites() {
        return [
          {
            source: "/api/movies",
            destination: `https://api.themoviedb.org/3/movie/popular?api_key=${API_KEY}`,
          },
          {
            // 👉 중요 포인트는 ":id"로 값을 넘긴다는 것이다!! 변환해주는 destination도 똑같이!
            source: "/api/movies/:id",
            destination: `https://api.themoviedb.org/3/movie/:id?api_key=${API_KEY}`,
          },
        ];
      },
      images: {
        domains: ["image.tmdb.org", "*"], // 사용하려는 이미지 호스트 이름 추가
      },
    };

    module.exports = nextConfig;
    ```

<br/>
<hr/>

## `next.config.js`

- nextJs 서버의 설정을 수정할 수 있다.

### Redirects 사용 방법

- 지정한 path로 들어온 접근을 변경된 주소로 이동시켜 준다.
- 더 이상 사용하지 않는 url로 들어올 경우 변경된 url로 보내줄 때 사용된다.
- 배열 형태로 되어있기에 원하면 계속 해서 Object를 늘려서 설정이 가능하다
- 사용 예시

  - next.config.js

    ```javascript
    // ✅ .evn파일에 작성한 API Key를 불러옴
    const API_KEY = process.env.API_KEY;

    /** @type {import('next').NextConfig} */
    const nextConfig = {
      reactStrictMode: true,
      //⭐️ 사용하려는 이미지의 도메인 주소를 추가해줘야한다.
      images: {
        domains: ["image.tmdb.org", "*"],
      },
    };

    module.exports = nextConfig;
    ```

### Rewrites 사용 방법

- 받아온 요청을 내가 지정한 요청으로 변경해서 요청을 보낸다.
- NexJs자체가 서버 역할을 하기 떄문에 가능한 기능이다.
- 개발자 도구의 Request부분에서도 이제 요청 시 들어있던 비밀키와 같은 정보도 숨길 수 있다.
- SpringBoot의 `application.protperties`와 비슷한 개념이라 생각하자
- 예시 코드

  - .env

    ```properties
        # API KEY
        API_KEY=시크릿키~
    ```

  - next.config.js

    ```javascript
    // ✅ .evn파일에 작성한 API Key를 불러옴
    const API_KEY = process.env.API_KEY;

    /** @type {import('next').NextConfig} */
    const nextConfig = {
      reactStrictMode: true,
      /**
       * 👉 redirects()와는 다르게 "source"로 접근한 값을 "destination"로 변경해서 요청 함
       */
      async rewrites() {
        return [
          {
            source: "/api/movies",
            destination: `https://api.themoviedb.org/3/movie/popular?api_key=${API_KEY}`,
          },
        ];
      },
    };

    module.exports = nextConfig;
    ```

### Rewrites - pathVariable 전달 방법

- 예시 코드

  - next.config.js

        ```javascript
        const API_KEY = process.env.API_KEY;

        /** @type {import('next').NextConfig} */
        const nextConfig = {
          reactStrictMode: true,
          async rewrites() {
            return [
             {
                // 👉 중요 포인트는 ":id"로 값을 넘긴다는 것이다!! 변환해주는 destination도 똑같이!
                source: "/api/movies/:id",
                destination: `https://api.themoviedb.org/3/movie/:id?api_key=${API_KEY}`,
            },
            ];
          },
        };

        module.exports = nextConfig;
        ```

<br/>
<hr/>

## pre rendering - 구버전용 .. 이제 쓸수 없음 레거시 코드에는 남아있을 수 있으니 .. 참고하자

- 특정 페이지 혹은 상황에 따라 데이터 목록을 로딩 후 보여지는 것이 아닌 서버에서 목록을 받아온 후 적용하게 할 수 있다.
  - 상황에 따라 `SEO`에 필요한 데이터를 홈 화면에 만들 경우 유용할 것으로 추측함
  - 로딩 화면이 없이 서버에서 데이터를 받고 그 후 다 받아진 이후 화면을 랜더링함.
- ⭐️ 사용 시 중요
  - `export`를 꼭 해줘야한다. --> `export async function `
  - 함수명이 틀리면 안된다. --> `getServerSideProps`
- 사용 예시

  - index.js

    ```javascript
    // 👉 { results } 룰 사용해서 ServerSideData를 받아옴
    export default function Home({ results }) {
      return (
        <div className="container">
          {results.map((item) => (
            <div className="movie" key={item.id}>
              <img
                src={`https://image.tmdb.org/t/p/w500/${item.poster_path}`}
              />
              <h4>{item.original_title}</h4>
            </div>
          ))}
        </div>
      );
    }

    // 👉 함수명이 중요함 NextJs에서 정해진 함수명임
    export async function getServerSideProps() {
      const { results } =
        await // 💬 서버에서 요청하므로 rewirte를 사용하기 위해서는 앞에 도메인 정보가 필수임
        (await fetch(`http://localhost:3000/api/movies`)).json();
      return {
        props: {
          results,
        },
      };
    }
    ```

<br/>
<hr/>

## pre rendering - NextJs13 버전 이상용

- fetch 옵션 중 `{ cache: 'no-store' }`를 사용해주자

  - 예시 코드

    ```javascript
    import { useEffect, useState } from "react";

    async function fetchData() {
      const res = await fetch("http://localhost:3000/api/movies", {
        // 👉 해당 옵션을 사용해주자
        cache: "no-store",
      });
      const data = await res.json();
      return data.results;
    }

    export default function Home() {
      const [results, setResults] = useState([]);

      useEffect(() => {
        fetchData().then((data) => {
          setResults(data);
        });
      }, []);

      return (
        <div className="container">
          {results.map((item) => (
            <div className="movie" key={item.id}>
              <img
                src={`https://image.tmdb.org/t/p/w500/${item.poster_path}`}
              />
              <h4>{item.original_title}</h4>
            </div>
          ))}
        </div>
      );
    }
    ```

<br/>
<hr/>

## Dynamic Routes

- 이전까지는 Path 정보가 하나 뿐인 컴포넌트를 불러오는 개념이었다면 이제는 변수값 혹은 좀 더 세분화된 url로 컴포넌트를 나눠서 사용가능하다.

### path를 좀 더 세분화

- 간단하게 그냥 폴더를 두면 그게 하나의 path가 된다.
- 중요한건 해당 폴더 또한 컴포넌트를 갖게 하고싶다면 `index.js`라는 이름으로 컴포넌트를 생성하면 된다.
- 구조
  - page
    - blackGom
      - index.js : `localhost:3000/blackGome` 시 해당 컴포넌트가 화면에 도출
      - all.js : `localhost:3000/blackGome/all`

### path를 변수로 받는 방법 - [Next13 이전]

- 간단하다 해당 폴더를 생성 한 후 `[변수명].js`로 만들면 해당 변수를 `useRouter` Hook을 이용해 값을 받을 수 있다.
- 폴더 구조

  - pages
    - movive
      - [id].js
  - 사용 예시

    - [id].js

      ```javascript
      import { useRouter } from "next/router";

      export default function Detail() {
        // ⭐️ Hooke을 이용해서 내가 지정한 id값을 받아올 수 있음
        const router = useRouter;
        console.log(router().query.id);
        return <div>이렇게 받을수 있지요~</div>;
      }
      ```

### path를 변수로 받는 방법 - [Next13 이후]

- 사용할 새그먼트명 폴더를 생성 후 `[변수명]`폴더 생성
- 해당 폴더 내부에 `page.js` 생성
- 매개변수로 `{ params }`를 받아서 사용

  - 폴더 구조
  - src
    - app
      - read
        - [...id] or [id]
          - page.js
  - 사용 예시

    - page.js

      ```javascript
      export default function page({ params }) {
        // 👉 접근 시 :  http://localhost:3000/read/1/23/4
        console.log(params); // { id: [ '1', '23', '4' ] }
        return <div>{params.id}</div>;
      }
      ```

<br/>
<hr/>

## `Link Tag`활용 및 `useRouter()`를 사용해서 같은 기능 구현

- 이벤트 함수를 생성하고 거기에 `useRouter()`를 사용해서 push해주면 된다.
  - ⭐️ 중요 포인트는 `useRouter()` 선언 위치가 `useEffect()` 밑에 있으면 에러가 뜬다 .
    - 사용에는 문제가 없지만 콘솔에 에러가 뜸
- `router.push()` 형태로 값을 넣어주면 된다.
- `{}` Object 구조를 사용하면 다양한 방법으로 사용이 가능하다.
  - 그냥 `router.push(url)` 사용 시 일반 이동
  - Object 구조일 경우 `quertParameter` 사용 가능
  - `router.push({}, "~~~" )`처럼 사용 시 Url 마스킹 가능
- 사용 예시

  - index.js

    ```javascript
    import { useRouter } from "next/router";

    export default function Home() {
      const [movies, setMovies] = useState([]);
      // ⭐️ 순서가 중요함 useEffect보다 아래있으면 에러 발생함
      const router = useRouter();
      // 👉 Link Tag를 사용하지 않고 해당 방법으로도 같은 기능 사용이 가능하다.
      const onClick = (id) => {
        /**
         * ✅ JSON 구조를 사용하면  url 말고도 queryParameter를 넘겨줄 수 있다
         * - pathname : 이동하려는 path 정보
         * - query {}  : queryParameter
         * - push({}, "이동 시 시 사용될 path정보")  >>> ⭐️ 두번째 매개변수를 통해 queryParameter를 숨길 수 있다!!
         *     - 이런 방식의 활용은 내부 로직을 모르는 사람이 볼때는 쿼리파람없이 해킹 가능 이네 하지만 사실은 쿼리파라미터가 없어서 튕겨낼 수 도 있다.
         * - 💬 Link 태그에서도 똑같이 사용이 가능하다 그냥 똑같이 넣으면 된다!!
         */
        router.push(
          { pathname: `/movies/${id}`, query: { title: "yooo" } },
          `/movies/${id}`
        );
      };

      return (
        <div className="container">
          {movies.map((item) => (
            <div className="movie" key={item.id}>
              <img
                // 👉 함수 호출
                onClick={() => onClick(item.id)}
                src={`https://image.tmdb.org/t/p/w500/${item.poster_path}`}
              />
            </div>
          ))}
        </div>
      );
    }
    ```

<br/>
<hr/>

## All-Catch

- 이전 예제에서는 `loclahost:3000/movies/:id` 와 같은 식으로 한개의 값 만 받아 왔었지만 여러개를 배열로 받을 수 있다.
- 자주 사용되지는 않지만 알아두면 필요할 경우 유용하게 사용할 수 있다.
- 사용 방법

  - 기존 예제에서 사용하던 `[id].js`파일 -> `[...id].js`로 변경하면 알아서 배열로 받아온다!
  - [...id].js

    ```javascript
    import { useRouter } from "next/router";

    export default function Detail() {
      const router = useRouter();
      console.log("------------------");
      console.log(router.query.id); // 👉 [] 형태로 들어옴

      const id = router.query.id;
      return <div>{id}</div>;
    }
    ```

<br/>
<hr/>

## 404 페이지 설정 방법

- 간단하게 `404.js`파일을 만들고 컴포넌트를 생성하면 끝이다.

  - 예시 코드

    ```javascript
    export default function Error404() {
      return <div>404Error</div>;
    }
    ```

<br/>
<hr/>

## 환경변수 사용 방법

- 개발 시 `local`환경과 `prod`환경의 사용 URL이 다를 수 있다.
- 해당 경우 일일이 변경해주는 것이 아닌 하나의 파일을 읽게끔 하면 된다 `.env`파일
- 사용 가능한 `.env`파일 종류
  - `.env` : 어떤 환경이든 읽음 공통 적으로 사용
  - `.env.local` : 개발 환경에서 읽음 `npm run dev`로 서버 실행 시 읽음
  - `.env.production` : 운영 환경에서 읽음 `npm build`를 통해 빌드된 서버 실행 시 읽음
- ⭐️ 만약 통신간 비밀키 와 같은 민감 정보를 사용할 경우라면 `.env`파일에 등록 후 `next.config.js`에서 읽게 끔 해주자 [ Rewrites 사용 방법 확인 ]
- 기본적인 `app router` 방식은 Server Component 방식이기 때문에 쉽게 사용 가능하지만 `use-client` 방식일 경우 사용 방식이 다르다.
- 사용 방법

  - .env.local

    ```properties
    # 👉 Server Component에서 사용 시
    #    - process.env.??
    API_URL=http://localhost:9999/topics

    # 👉 Client Component에서 사용 시 꼭  "NEXT_PUBLIC_???"형식으로 사용 해야함
    #    - process.env.NEXT_PUBLIC_???
    NEXT_PUBLIC_API_URL=http://localhost:9999/topics

    ```

  - Component별 사용
    - Server Component : `const res = await fetch(process.env.API_URL)`
      - 위와 같이 `process.env.???`를 사용해서 불러옴
    - Client Component : `const res = await fetch(process.env.NEXT_PUBLIC_API_URL + `/${params.id}`, {cache: "no-cache",});`
      - 위와 같이 `process.env.NEXT_PUBLIC_A???`를 사용해서 불러옴

<br/>
<hr/>

## 개발 시 유용한 JSON 서버 개발 방법

- 서버 연동 전 서버가 개발되어 있지 않다면 간단하게 받아오는 것이 가능하다
  - 설치방법
    - `npx json-server --port 9999 --watch db.json`
      - db.json 파일을 감시중이라 변경하면 해당 값에 맞에 반환이 가능하다.

<br/>
<hr/>

## Recoil

- 전역관리 상태 관리를 위한 Library 이다.
- React 특성상 하위 하위.... 하위 컴포넌트에 데이터를 전달하기 위해서는 props를 전달해야하는데 그렇게되면 중간 컴포넌트들이 중계자가 되는 불편함이 있다.
  - 이러한 불편함을 덜어주고자 전역적으로 관리할 데이터를 지정하는 개념이다.
- 사용방법

  - 1 . `npm install recoil`
  - 2 . 메인 js 부분에 감시할 수 있도록 `<RecoilRoot></RecoilRoot>` 설정

    - \_app.js

      ```javascript
      import "@/styles/globals.css";
      import { RecoilRoot } from "recoil";

      export default function App({ Component, pageProps }) {
        return;
        <RecoilRoot>
          <Component {...pageProps} />
        </RecoilRoot>;
      }
      ```

  - 3 . 사용할 Recoil State 선언

    - 위치는 상관없으나 기본적으로 store라는 폴더에 자주 사용함
    - countState.js

      ```javascript
      // 👉 Recoil에 사용할 번수선언을 위한 Import
      import { atom } from "recoil";

      export const countState = atom({
        // 👉 고유 식별 Key 지정 중복되면 안된다!
        key: "count",
        // 👉 사용 디폴트 값 지정 여러가지 형태 가능 {}, [] 등등
        default: 10,
      });
      ```

  - 4 . 사용 js

    - index.js

      ```javascript
      import React, { useState } from "react";

      // 👉 Recouil State Import
      import { countState } from "../store/countState";
      // 👉 Recoil 함수 Import
      import { useRecoilValue, useRecoilState } from "recoil";

      function Counter() {
        // 👉 useRecoilState(상태변수)를 사용해서 불러옴 useState() 와 사용방법이 똑같음
        const [count, setCount] = useRecoilState(countState);
        return (
          <div>
            <h1>Counter : {count}</h1>
            <button
              onClick={() => {
                setCount(count + 1);
              }}
            >
              +
            </button>
          </div>
        );
      }
      function DisplayCount() {
        // 값만 읽어오는 Recoil 함수
        const count = useRecoilValue(countState);
        return (
          <div>
            <h1>받아온 값을 보여주기만하는 컴포넌트 {count} </h1>
          </div>
        );
      }

      export default function Home() {
        return (
          <div>
            <Counter />
            <hr></hr>
            <DisplayCount></DisplayCount>
          </div>
        );
      }
      ```

- Recoil 사용 가능 import 메서드
  - useRecoilState : react의 useState랑 동일한 기능이라고 생각하면 된다.
  - useSetRecoilState : useState에서 setter만 있는것
  - useRecolValue : useState에서 value만 있는것
  - useResetRecoilState : 기본값으로 초기화 시키는 기능

<br/>
<hr/>

## React Cookie

- React에서 Cookie를 다룰 수 있는 Library 이다.
- React에서 쓰던 명령어와 비슷하여 쉽게 사용이 가능하다.
- 사용 방법

  - `npm install reack-cookie` 설치
  - 예시 코드

    ```javascript
    import { useCookies } from "react-cookie";

    export default function cookie() {
      // 👉 Cookie 사용 State 선언 -- 사용될 cookie의 key값을 배열로 기본값 설정 가능
      const [cookies, setCookie, removeCookie] = useCookies(["rememberId"]);

      // 👉 cookies.?? 를 사용해서 값의 유무 체크가 가능
      function checkCookie() {
        return cookies.rememberId === undefined;
      }

      // 👉 Cookie의 사용될 값 지정
      const handleSetCookie = () => {
        // 쿠키 저장 기간 설정
        const expirationDate = new Date();
        expirationDate.setDate(expirationDate.getDate() + 7);

        setCookie(
          "Key값 지정",
          "Value 값 지정",
          // 옵션 지정
          {
            path: "/", // 사용 범위 지정
            expires: expirationDate, // 유지기간 설정 - 자유 없어도 된다.
          }
        );
      };

      // 👉 Cookie 삭제
      removeCookie("삭제하고 싶은 Key 값 지정", { path: "/" });

      return <></>;
    }
    ```

<br/>
<hr/>

## 구조

my-nextjs-app/
├── pages/
│ ├── index.js
│ ├── about.js
│ ├── ...
├── components/
│ ├── Header.js
│ ├── Footer.js
│ ├── ...
├── customHook
│ ├── login
│ │ ├── Hook....js
├── styles/
│ ├── global.css
│ ├── ...
├── public/
│ ├── images/
│ │ ├── ...
│ ├── ...
├── package.json
├── ...
